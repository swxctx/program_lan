一般向函数中传递参数 用到比较多的是直接传参
即： void fun(int a,int b);
这种传参方式都是将实参进行拷贝后，将一个副本传递到了fun函数中。
如果在fun函数外定义了 int out_a =1; int out_b =2，将这两个值传入：fun(out_a,out_b)
然后在fun函数中进行对参数的变化操作，如：out_a++, out_b++
退出函数后会发现out_a 和 out_b并没有发生变化，因为fun中只是对它们的副本进行操作，没有对变量本身做任何改动。

这种时候，如果想让传入的变量能够在函数中直接进行变化，即传入的是变量本身而不是一个副本，
那么 可以用到引用的方式，定义函数：void fun(int& a,int& b);
这样以后再传入fun(out_a,out_b) ， out_a++, out_b++
退出函数时，变量也已经改变。
【像这样直接操作变量本身的方法还有指针传递。。。】

假如有这样一种情况：

主函数：                  out函数：                   In函数
int main()                void out(****)            void In(****)        
{                         {                         {
  int a,int b;              in(c,d);                    e++;
  out(a,b);               }                             f++;
}                                                   }

即，希望外部传入的变量在函数嵌套调用时能够直接在内部的函数中被改变
那么这里，out函数和in函数的形参分别应该声明为：void out(int& c,int& d)   void In(int& e,int& f)
这样，传入的参数就一直是他自己，而不是副本
如果只是把OUT函数的形参定义成引用，in函数没有，那么最终变量还是不会被改变
因为虽然out函数中传入了a,b的本身，但是再传入到in的时候，又成了a,b的副本，结果你懂的解闯。

再有一个数组作为函数参数进行传递：
-----------先了解---------
有一个数组 int array[3]={1，2，3};
那么数组名字 array同时也是这个数组首个元素的地址 
【array + 1并不是下一个元素的地址，而是指向了array中第三个元素还要后面一位的地址】
 * 代表取值，那么 *array 是这个数组的第一个值：1
----------我是分割线-----------
定义一个函数,参数为一个数组
int Fun（int a[],int b）
使用这个函数时：Fun（array,sizeof(array)）; 即传入的是这个数组的首地址

具体：
   int Fun(int a[],int b)   【b是这个数组的大小】
   {
      for(int i=0; i < b; i++)
      {
            (*a)++
      }
   }
结束后 这个数组变为： array[3]={2，3，4}
                                   
                                               
                               
